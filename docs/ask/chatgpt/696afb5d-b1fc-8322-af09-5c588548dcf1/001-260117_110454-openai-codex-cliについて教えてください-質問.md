# openai-codex-cliについて教えてください-質問

## 📅 メタ情報
- **日時**: 2026/1/17 11:04:54
- **プロジェクト**: tproj
- **AIモデル**: ChatGPT
- **チャットID**: 696afb5d-b1fc-8322-af09-5c588548dcf1
- **会話番号**: 1
- **チャットURL**: https://chatgpt.com/c/696afb5d-b1fc-8322-af09-5c588548dcf1

## ❓ 質問

OpenAI Codex CLIについて教えてください。

質問：
1. `codex resume --last` は、特定のプロジェクトフォルダの履歴を再開するのか、それともグローバルな最後のセッションを再開するのか？
2. プロジェクトフォルダごとに履歴を管理・再開する方法はあるか？
3. `--full-auto` と `--ask-for-approval never` の違いは何か？
4. 履歴がない場合に `codex resume --last` を実行するとどうなるか？エラーになるか、新規セッションが始まるか？

コンテキスト：
- tmuxでcodexを自動起動するスクリプトを書いている
- プロジェクトごとに履歴を引き継ぎたい
- 履歴がなければ新規で起動したい
- 権限確認を最小限にしたい

## 💬 回答

以下、公式ドキュメントベースで、あなたの4つの質問にそのまま答えます（tmux自動起動の設計に落とし込める形で）。

1. codex resume --last は「フォルダ単位」か「グローバル」か？
**基本は“いまいる作業ディレクトリ（＝カレントWD）基準”**です。


codex resume は「最近のセッション」をピッカー表示します。 developers.openai.com


codex resume --all を付けると、カレントWD以外のセッションも含めて表示できます（＝グローバル寄り）。 developers.openai.com


codex resume --last はピッカーをスキップして「最も最近のセッション」に飛びます。 developers.openai.com


さらに changelog でも、resume --last が current cwd（カレントWD）を尊重し、--all がオーバーライドする趣旨が明記されています。 developers.openai.com


つまり、プロジェクトフォルダで実行すれば、そのプロジェクトの“最後”が取れる設計になっています（--all を付けると混ざる）。

2. プロジェクトフォルダごとに履歴を管理・再開する方法
やり方は大きく2つあります。
A) いちばん簡単：「そのプロジェクトで実行する」運用


プロジェクト直下で codex resume → そのWDに紐づくセッションが出る


--last ならそのWDの“最後”に直行


別プロジェクトのセッションも見たい時だけ --all developers.openai.com


また、セッションIDはピッカー / /status / ~/.codex/sessions/ 配下から取れます。 developers.openai.com
B) もっと強力：プロジェクトごとに CODEX_HOME を分ける
Codex はローカル状態（設定・履歴など）を CODEX_HOME（デフォルト ~/.codex）配下に保存します。 developers.openai.com
なので、プロジェクトごとに：


CODEX_HOME=$(pwd)/.codex のようにすると
**そのプロジェクト専用の「状態・履歴・（場合によっては認証情報）」**に分離できます。 developers.openai.com+1



注意：CODEX_HOME を分けると、認証キャッシュも分かれる可能性があります（ただし keyring 保存なら影響が小さいことも）。認証の扱いはあなたの環境次第。


3. --full-auto と --ask-for-approval never の違い
これは**「自動でやっていい範囲（sandbox）」**と **「止まって許可を求めるか（approval）」**の組み合わせの話です。


--full-auto は --sandbox workspace-write --ask-for-approval on-request のショートカットです。 developers.openai.com


workspace内の読み書き・コマンド実行はかなり自動で進む


ただし「必要なときは止まって許可を求める（on-request）」 developers.openai.com




--ask-for-approval never は 許可プロンプトを一切出しません。 developers.openai.com


その代わり、あなたが設定したsandbox制約の範囲で「できることだけ」やります（できないことは“ベストエフォートで回避”）。 developers.openai.com


公式の例でも、CI向けに --sandbox read-only --ask-for-approval never が提示されています。 developers.openai.com


なお「ネットワーク込みで編集も実行も、承認なしで全部やらせたい」なら danger-full-access や --yolo（危険）側を使う、と明記されています。 developers.openai.com




あなたの「権限確認を最小限にしたい」は、だいたい --ask-for-approval never を使う方向になります（ただし安全性とのトレードオフはsandboxで調整）。

4. 履歴がない場合の codex resume --last はどうなる？
ここは公式が“エラーになる/新規になる”を明言していません（少なくとも私が見た範囲の公式ページでは断定できない）。
ただ、前提として：


セッション再開はローカルに保存されたトランスクリプト/セッション情報を使います developers.openai.com+1


セッションIDは ~/.codex/sessions/ 配下などに存在します developers.openai.com


履歴保存自体は history.persistence で制御され、history.jsonl は CODEX_HOME 配下に保存されます developers.openai.com+1


なので、“ないなら再開できない”のは確実です。実務的には「失敗したら新規起動」に倒すのが堅いです。

tmux自動起動で「プロジェクトごとに再開・なければ新規・承認最小」を満たす定番パターン
一番ラクで堅いのはこれです（挙動がエラーでも非エラーでも吸収できる）：
bashコードをコピーする#!/usr/bin/env bash
set -euo pipefail

proj="$1"
cd "$proj"

# 承認を最小化する例（workspace内で完結させる）
# ※必要に応じて --sandbox read-only / workspace-write を選ぶ
FLAGS=(--sandbox workspace-write --ask-for-approval never)

# 「そのプロジェクトの最後」を試す。ダメなら新規。
codex resume --last "${FLAGS[@]}" || codex "${FLAGS[@]}"



ポイントは --all を付けないこと：付けると他プロジェクトの“最後”が混ざり得ます developers.openai.com+1


さらに完全分離したいなら、プロジェクトごとに CODEX_HOME を切る： developers.openai.com+1


bashコードをコピーするCODEX_HOME="$proj/.codex" codex resume --last "${FLAGS[@]}" || CODEX_HOME="$proj/.codex" codex "${FLAGS[@]}"


必要なら、あなたの今の tmux スクリプト構造（pane/window構成、起動コマンド、プロジェクトの渡し方）に合わせて、**“セッションID指定で確実に復帰する版”**や、codex exec resume --last を混ぜた 非対話/対話ハイブリッド版にも落とせます。


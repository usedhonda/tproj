#!/bin/zsh
set -euo pipefail
setopt KSH_ARRAYS  # 0-based array indexing (bash compatibility)

# Codex ãƒã‚¤ãƒŠãƒªã«ç½²åï¼ˆmacOS ã‚³ãƒ¼ãƒ‰ç½²åå•é¡Œã®å›é¿ï¼‰
sign_codex() {
  if [[ "$(uname)" == "Darwin" ]]; then
    find /opt/homebrew/lib/node_modules/@openai/codex -type f \( -perm +111 -o -name "*.node" \) -exec codesign -s - -f {} \; 2>/dev/null || true
  fi
}

# ä½¿ã„æ–¹:
#   tproj              # ç¾åœ¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèµ·å‹•
#   tproj -s           # å˜ä¸€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ¼ãƒ‰å¼·åˆ¶ï¼ˆworkspace.yaml ç„¡è¦–ï¼‰
#   tproj -r host      # ãƒªãƒ¢ãƒ¼ãƒˆãƒ›ã‚¹ãƒˆã«SSHæ¥ç¶šã—ã¦èµ·å‹•
#
# npm update ã¯è‡ªå‹•å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚æ‰‹å‹•ã§æ›´æ–°ã—ã¦ãã ã•ã„:
#   npm update -g @anthropic-ai/claude-code @openai/codex

show_help() {
  cat << 'EOF'
tproj - tmux project launcher

Usage:
  tproj [OPTIONS]
  tproj stop           Gracefully stop (Ctrl+C -> /exit -> wait -> kill)
  tproj kill           Immediately kill all tproj sessions (tmux kill-session)

Options:
  --add [ALIAS]      Add workspace column (no arg: duplicate current, with alias: from workspace.yaml)
  --check            Show workspace.yaml projects, aliases, and enabled status
  -c, --columns N    Start with only the first N projects from workspace.yaml
  -s, --single       Force single-project mode (ignore workspace.yaml)
  -r, --remote HOST  SSH remote connection
  -h, --help         Show this help message

Note:
  npm update is NOT run automatically to avoid conflicts.
  Update manually when needed:
    npm update -g @anthropic-ai/claude-code @openai/codex

Modes:
  Single Project Mode (default)
    - 3-pane layout: Claude Code, Codex, yazi
    - Session name: <project-name>

  Multi-Project Mode (workspace)
    - Enabled when ~/.config/tproj/workspace.yaml exists
    - Multiple columns, each with Claude Code + Codex
    - Session name: tproj-workspace
    - Use -s to force single mode

Workspace Configuration:
  File: ~/.config/tproj/workspace.yaml

  Example:
    projects:
      - /path/to/project1
      - /path/to/project2
      - /path/to/project3

Key Bindings:
  Prefix + y    Toggle yazi (in active column)
  Prefix + arrows    Switch between panes/columns

Examples:
  tproj                   # Auto-detect mode (workspace or single)
  tproj --add             # Add one column in running tproj-workspace
  tproj -s                # Force single mode
  tproj -r macmini        # SSH remote connection (single mode only)

For more information, see: README.md
EOF
}

NO_UPDATE=true  # npm update ã¯æ‰‹å‹•ã§å®Ÿè¡Œã—ã¦ãã ã•ã„
REMOTE_HOST=""
FORCE_SINGLE_MODE=false
ADD_MODE=false
ADD_ALIAS=""
CHECK_MODE=false
MAX_COLUMNS=""  # ç©º = åˆ¶é™ãªã—

# stop/kill ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰
if [[ "${1:-}" == "stop" ]]; then
  stop_session
  exit 0
fi
if [[ "${1:-}" == "kill" ]]; then
  kill_session
  exit 0
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) show_help; exit 0 ;;
    --check) CHECK_MODE=true; shift ;;
    --add)
      ADD_MODE=true; shift
      if [[ $# -gt 0 && "$1" != -* ]]; then
        ADD_ALIAS="$1"; shift
      fi
      ;;
    -c|--columns)
      [[ -z "${2:-}" ]] && { echo "Error: -c requires a number" >&2; exit 1; }
      MAX_COLUMNS="$2"; shift 2 ;;
    -n|--no-update) NO_UPDATE=true; shift ;;
    -s|--single) FORCE_SINGLE_MODE=true; shift ;;
    -r|--remote)
      [[ -z "${2:-}" ]] && { echo "Error: -r requires a hostname" >&2; exit 1; }
      REMOTE_HOST="$2"; shift 2 ;;
    -*) echo "Unknown option: $1" >&2; echo "Run 'tproj --help' for usage" >&2; exit 1 ;;
    *) echo "Unexpected argument: $1" >&2; echo "Run 'tproj --help' for usage" >&2; exit 1 ;;
  esac
done

# ã‚»ãƒƒã‚·ãƒ§ãƒ³å­˜åœ¨ãƒã‚§ãƒƒã‚¯é–¢æ•°
has_claude_session() {
  local abs_path="$1"
  local encoded="${abs_path//\//-}"
  local proj_dir="$HOME/.claude/projects/$encoded"
  [[ -f "$proj_dir/sessions-index.json" ]] || ls "$proj_dir"/*.jsonl &>/dev/null
}

# ãƒšã‚¤ãƒ³ãƒ©ãƒ™ãƒ«ç”Ÿæˆ
# å½¢å¼: {name}.{cc|cdx} {persona} / {name}.{cc|cdx}@{host} {persona}
# å¼•æ•°: project_type project_host project_path tool_kind [alias]
build_pane_label() {
  local project_type="$1"
  local project_host="$2"
  local project_path="$3"
  local tool_kind="$4"
  local project_alias="${5:-}"

  local suffix="cc"
  [[ "$tool_kind" == "Codex" ]] && suffix="cdx"

  local project_name
  if [[ -n "$project_alias" ]]; then
    project_name="$project_alias"
  else
    project_name="$(basename "$project_path" 2>/dev/null || true)"
    [[ -z "$project_name" || "$project_name" == "." || "$project_name" == "/" ]] && project_name="unknown"
  fi

  local host_suffix=""
  if [[ "$project_type" == "remote" && -n "$project_host" ]]; then
    host_suffix="@${project_host}"
  fi

  local persona
  persona="$(cc-persona --label "$project_path" "$suffix" 2>/dev/null || true)"

  echo "${project_name}.${suffix}${host_suffix} ${persona}"
}

# @tproj ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’å–å¾—ï¼ˆå…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼‰
find_tproj_sessions() {
  tmux list-sessions -F '#{session_name}:#{@tproj}' 2>/dev/null \
    | grep ':true$' | cut -d: -f1
}

# tmux ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ã‚’ç›´åˆ—åŒ–ã™ã‚‹å…±æœ‰ãƒ­ãƒƒã‚¯
TPROJ_LAYOUT_LOCK_NAME="tproj-layout"
TPROJ_LAYOUT_LOCK_HELD=false

acquire_layout_lock() {
  tmux wait-for -L "$TPROJ_LAYOUT_LOCK_NAME" 2>/dev/null || return 1
  TPROJ_LAYOUT_LOCK_HELD=true
}

release_layout_lock() {
  if [[ "$TPROJ_LAYOUT_LOCK_HELD" == "true" ]]; then
    tmux wait-for -U "$TPROJ_LAYOUT_LOCK_NAME" 2>/dev/null || true
    TPROJ_LAYOUT_LOCK_HELD=false
  fi
}

trap 'release_layout_lock' EXIT INT TERM

# Collect all descendant PIDs of given PIDs (BFS via pgrep -P)
collect_descendant_pids() {
  local queue=("$@")
  local all=()
  while [[ ${#queue[@]} -gt 0 ]]; do
    local cur="${queue[0]}"
    queue=("${queue[@]:1}")
    local ch
    ch=$(pgrep -P "$cur" 2>/dev/null) || true
    while IFS= read -r c; do
      [[ -n "$c" ]] && all+=("$c") && queue+=("$c")
    done <<< "$ch"
  done
  printf '%s\n' "${all[@]}"
}

# Collect descendant PIDs from all panes of given tproj sessions
collect_session_descendants() {
  local sessions="$1"
  local pane_pids_arr=()
  while IFS= read -r sess; do
    [[ -z "$sess" ]] && continue
    local pp
    pp=$(tmux list-panes -s -t "$sess" -F '#{pane_pid}' 2>/dev/null) || continue
    while IFS= read -r p; do
      [[ -n "$p" ]] && pane_pids_arr+=("$p")
    done <<< "$pp"
  done <<< "$sessions"
  [[ ${#pane_pids_arr[@]} -eq 0 ]] && return 0
  collect_descendant_pids "${pane_pids_arr[@]}"
}

# GUI ãƒ—ãƒ­ã‚»ã‚¹æ¤œå‡ºï¼ˆ.app ã¨é–‹ç™ºç‰ˆç›´èµ·å‹•ã®ä¸¡æ–¹ã‚’æ¤œå‡ºï¼‰
_tproj_gui_running() {
  pgrep -f '\.build/.*/tproj$|tproj\.app/' >/dev/null 2>&1
}

# GUI App ãƒ‘ã‚¹æ­£è¦åŒ–ï¼ˆ.app ã‹ Contents/MacOS/tproj ã®ã©ã¡ã‚‰ã§ã‚‚å—ã‘å–ã‚‹ï¼‰
_normalize_gui_app_path() {
  local raw="$1"
  local path
  [[ -z "$raw" ]] && return 1

  path="$raw"
  if [[ "$path" == "~/"* ]]; then
    path="$HOME/${path#~/}"
  fi
  [[ -z "$path" || "$path" == "null" ]] && return 1

  if [[ "$path" == *.app/Contents/MacOS/* ]]; then
    path="${path%%.app/Contents/MacOS/*}.app"
  fi
  [[ "$path" == *.app ]] || return 1
  [[ -d "$path" ]] || return 1

  echo "$path"
}

_read_workspace_gui_app_path() {
  local ws_config="$HOME/.config/tproj/workspace.yaml"
  [[ -f "$ws_config" ]] || return 1
  command -v yq >/dev/null 2>&1 || return 1

  local raw
  raw=$(yq -r '.gui.app_path // ""' "$ws_config" 2>/dev/null || true)
  [[ -z "$raw" || "$raw" == "null" ]] && return 1

  _normalize_gui_app_path "$raw"
}

# GUI èµ·å‹•ã‚¿ãƒ¼ã‚²ãƒƒãƒˆé¸æŠï¼ˆ.app ã®ã¿ï¼‰
# å„ªå…ˆé †ä½:
#   1) TPROJ_GUI_APP_PATH ç’°å¢ƒå¤‰æ•°
#   2) ~/.config/tproj/workspace.yaml ã® gui.app_path
#   3) tproj workspace å†…ã® apps/tproj/dist/tproj.app
#   4) ç¾åœ¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ root ã® apps/tproj/dist/tproj.app
#   5) é…å¸ƒç‰ˆã®æ¨™æº–é…ç½®ï¼ˆ~/Applications, /Applicationsï¼‰
#
# è¿”ã‚Šå€¤ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ:
#   app|/path/to/tproj.app
_find_gui_target() {
  local p app configured

  configured="${TPROJ_GUI_APP_PATH:-}"
  if [[ -n "$configured" ]]; then
    app="$(_normalize_gui_app_path "$configured" 2>/dev/null)" \
      && { echo "app|$app"; return 0; }
  fi

  app="$(_read_workspace_gui_app_path 2>/dev/null)" \
    && { echo "app|$app"; return 0; }

  for p in "${PROJECT_PATHS[@]}"; do
    app="$p/apps/tproj/dist/tproj.app"
    [[ -d "$app" ]] && { echo "app|$app"; return 0; }
  done

  app="$root/apps/tproj/dist/tproj.app"
  [[ -d "$app" ]] && { echo "app|$app"; return 0; }

  for app in "$HOME/Applications/tproj.app" "/Applications/tproj.app"; do
    [[ -d "$app" ]] && { echo "app|$app"; return 0; }
  done

  return 1
}

# TprojApp GUI ã‚’èµ·å‹•/å†è¡¨ç¤º
launch_tproj_gui() {
  local target kind path
  target="$(_find_gui_target 2>/dev/null)" || return 0
  kind="${target%%|*}"
  path="${target#*|}"
  [[ -z "$path" ]] && return 0

  [[ "$kind" == "app" ]] || return 0
  if _tproj_gui_running; then
    # æ—¢å­˜ãƒ—ãƒ­ã‚»ã‚¹ãŒã„ã‚‹å ´åˆã‚‚å†è¡¨ç¤ºã™ã‚‹
    open -a "$path" >/dev/null 2>&1 \
      || osascript -e 'tell application id "com.usedhonda.tproj.desktop" to activate' >/dev/null 2>&1 \
      || true
    return 0
  fi

  # åˆå›ã¯èƒŒæ™¯èµ·å‹•ï¼ˆTerminal ã« "Last login ...; exit" ã‚’å‡ºã•ãªã„ï¼‰
  open -g "$path" >/dev/null 2>&1 || true
}

# GUI ã‚¢ãƒ—ãƒªçµ‚äº†ï¼ˆkeep_alive=false ã®å ´åˆã®ã¿ï¼‰
stop_tproj_gui_if_needed() {
  local keep_alive="true"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  local ws_config="$HOME/.config/tproj/workspace.yaml"

  if [[ -f "$ws_config" ]]; then
    keep_alive=$(yq -r '.gui.keep_alive // "true"' "$ws_config" 2>/dev/null || echo "true")
  fi

  if [[ "$keep_alive" != "true" ]]; then
    pkill -f '\.build/.*/tproj$|tproj\.app/' 2>/dev/null || true
  fi
}

# Kill orphaned MCP server processes (PPID=1 = reparented to launchd)
cleanup_orphaned_mcp() {
  local orphans
  orphans=$(ps -eo pid=,ppid=,command= 2>/dev/null | \
    awk '$2 == 1' | \
    grep -E '(context7-mcp|playwright-mcp|chrome-ai-bridge|claude-in-chrome-mcp|@playwright/mcp|@upstash/context7)' | \
    awk '{print $1}') || true
  [[ -z "$orphans" ]] && return 0
  while IFS= read -r pid; do
    [[ -n "$pid" ]] && kill -TERM "$pid" 2>/dev/null || true
  done <<< "$orphans"
}

# Kill surviving descendant processes after session termination
kill_surviving_descendants() {
  local desc_pids="$1"
  [[ -z "$desc_pids" ]] && return 0
  while IFS= read -r pid; do
    [[ -z "$pid" ]] && continue
    # Only kill if still running
    kill -0 "$pid" 2>/dev/null && kill -TERM "$pid" 2>/dev/null || true
  done <<< "$desc_pids"
}

# ã‚»ãƒƒã‚·ãƒ§ãƒ³å³æ™‚çµ‚äº†ï¼ˆtmux kill-session ã®ã¿ï¼‰
kill_session() {
  local sessions
  sessions=$(find_tproj_sessions) || true

  if [[ -z "$sessions" ]]; then
    echo "No active tproj session" >&2
    return 0
  fi

  # Collect descendant PIDs before killing (to clean up MCP servers)
  local desc_pids
  desc_pids=$(collect_session_descendants "$sessions") || true

  while IFS= read -r session; do
    [[ -z "$session" ]] && continue
    pkill -TERM -f "bin/team-watcher" 2>/dev/null || true
    tmux kill-session -t "$session" 2>/dev/null || true
  done <<< "$sessions"

  # Kill surviving MCP server processes
  kill_surviving_descendants "$desc_pids"
  cleanup_orphaned_mcp

  rm -f /tmp/tproj-dead-agents
  stop_tproj_gui_if_needed
  echo "Session killed" >&2
}

# ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«çµ‚äº†ï¼ˆCC/Codex ã«çµ‚äº†ã‚·ã‚°ãƒŠãƒ«é€ä¿¡å¾Œ killï¼‰
stop_session() {
  local sessions panes pane_info pane_id role waited

  sessions=$(find_tproj_sessions) || true

  if [[ -z "$sessions" ]]; then
    echo "No active tproj session" >&2
    return 0
  fi

  # Collect descendant PIDs before stopping (to clean up MCP servers)
  local desc_pids
  desc_pids=$(collect_session_descendants "$sessions") || true

  while IFS= read -r session; do
    [[ -z "$session" ]] && continue

    # å…¨ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒšã‚¤ãƒ³ä¸€è¦§ï¼ˆdev + gitï¼‰
    panes=$(tmux list-panes -s -t "$session" -F '#{pane_id}:#{@role}' 2>/dev/null) || continue

    # Phase 1: ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«çµ‚äº†ã‚·ã‚°ãƒŠãƒ«
    while IFS= read -r pane_info; do
      [[ -z "$pane_info" ]] && continue
      pane_id="${pane_info%%:*}"
      role="${pane_info#*:}"

      case "$role" in
        claude|claude-p*)
          tmux send-keys -t "$pane_id" C-c 2>/dev/null || true
          ;;
        codex|codex-p*)
          tmux send-keys -t "$pane_id" C-c 2>/dev/null || true
          ;;
        yazi|yazi-p*)
          tmux send-keys -t "$pane_id" q 2>/dev/null || true
          ;;
        agent-*)
          tmux send-keys -t "$pane_id" C-c 2>/dev/null || true
          ;;
      esac
    done <<< "$panes"

    # Ctrl+C ã®åŠ¹æœã‚’å¾…ã¤
    sleep 0.3

    # ãƒ­ãƒ¼ãƒ«åˆ¥çµ‚äº†ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡ï¼ˆCC=exit, Cdx/Agent=/exitï¼‰
    while IFS= read -r pane_info; do
      [[ -z "$pane_info" ]] && continue
      pane_id="${pane_info%%:*}"
      role="${pane_info#*:}"

      case "$role" in
        claude|claude-p*|terminal-p*)
          tmux send-keys -t "$pane_id" "exit" C-m 2>/dev/null || true
          ;;
        codex|codex-p*|agent-*)
          tmux send-keys -t "$pane_id" "/exit" C-m 2>/dev/null || true
          ;;
      esac
    done <<< "$panes"

    # Phase 2: ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«çµ‚äº†å¾…æ©Ÿï¼ˆæœ€å¤§3ç§’ï¼‰
    waited=0
    while [[ $waited -lt 30 ]]; do
      if ! tmux has-session -t "$session" 2>/dev/null; then
        break
      fi
      sleep 0.1
      ((waited++)) || true
    done

    # team-watcher ãƒ‡ãƒ¼ãƒ¢ãƒ³ã‚’åœæ­¢
    pkill -TERM -f "bin/team-watcher" 2>/dev/null || true

    # Phase 3: æ®‹å­˜ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å¼·åˆ¶çµ‚äº†
    tmux kill-session -t "$session" 2>/dev/null || true
  done <<< "$sessions"

  # Kill surviving MCP server processes
  kill_surviving_descendants "$desc_pids"
  cleanup_orphaned_mcp

  # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  rm -f /tmp/tproj-dead-agents

  stop_tproj_gui_if_needed
  echo "Session stopped" >&2
}

# æ—¢å­˜ tproj-workspace ã«å³åˆ—ã‚’è¿½åŠ 
# å¼•æ•°ãªã—: ç¾åœ¨ã®ãƒšã‚¤ãƒ³ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’è¤‡è£½
# å¼•æ•°ã‚ã‚Š: add_workspace_column <path> <type> <host> [alias]
add_workspace_column() {
  local explicit_path="${1:-}"
  local explicit_type="${2:-}"
  local explicit_host="${3:-}"
  local explicit_alias="${4:-}"
  local session="tproj-workspace"
  local src_pane src_project src_remote_host src_remote_path
  local src_type src_host src_path src_dir src_alias
  local parsed parsed_host parsed_path
  local max_col new_col
  local right_claude new_claude new_codex
  local claude_title codex_title claude_cmd

  acquire_layout_lock || {
    echo "Error: failed to acquire layout lock" >&2
    exit 1
  }

  if [[ -z "${TMUX:-}" ]]; then
    echo "Error: --add must be run inside tmux" >&2
    exit 1
  fi

  tmux has-session -t "$session" 2>/dev/null || {
    echo "Error: $session is not running" >&2
    exit 1
  }

  tmux list-panes -t "$session:dev" >/dev/null 2>&1 || {
    echo "Error: $session:dev not found" >&2
    exit 1
  }

  if [[ -n "$explicit_path" ]]; then
    # ã‚¨ã‚¤ãƒªã‚¢ã‚¹ãƒ¢ãƒ¼ãƒ‰: å¼•æ•°ã‚’ãã®ã¾ã¾ä½¿ç”¨
    src_type="$explicit_type"
    src_host="$explicit_host"
    src_path="$explicit_path"
    src_alias="${explicit_alias:-$(basename "$src_path")}"
    src_dir="$src_path"
    [[ "$src_type" == "remote" ]] && src_dir="/tmp"
  else
    # ç¾åœ¨ã®ãƒšã‚¤ãƒ³ã‹ã‚‰å–å¾—ï¼ˆæ—¢å­˜å‹•ä½œï¼‰
    src_pane="${TMUX_PANE:-}"
    [[ -z "$src_pane" ]] && src_pane="$(tmux display-message -p '#{pane_id}' 2>/dev/null || true)"
    [[ -z "$src_pane" ]] && {
      echo "Error: cannot detect current pane" >&2
      exit 1
    }

    src_project="$(tmux display-message -t "$src_pane" -p '#{@project}' 2>/dev/null || true)"
    src_remote_host="$(tmux display-message -t "$src_pane" -p '#{@remote_host}' 2>/dev/null || true)"
    src_remote_path="$(tmux display-message -t "$src_pane" -p '#{@remote_path}' 2>/dev/null || true)"
    src_alias="$(tmux display-message -t "$src_pane" -p '#{@alias}' 2>/dev/null || true)"

    if [[ "$src_project" == ssh://* ]]; then
      src_type="remote"
      parsed="${src_project#ssh://}"
      parsed_host="${parsed%%/*}"
      parsed_path="/${parsed#*/}"
      src_host="${src_remote_host:-$parsed_host}"
      src_path="${src_remote_path:-$parsed_path}"
      src_dir="/tmp"
      [[ -z "$src_host" || -z "$src_path" ]] && {
        echo "Error: failed to resolve remote host/path from current pane" >&2
        exit 1
      }
    else
      src_type="local"
      src_host=""
      src_path="$src_project"
      [[ -z "$src_path" || "$src_path" == "null" ]] && \
        src_path="$(tmux display-message -t "$src_pane" -p '#{pane_current_path}' 2>/dev/null || true)"
      [[ -z "$src_path" ]] && {
        echo "Error: failed to resolve local project path from current pane" >&2
        exit 1
      }
      src_dir="$src_path"
    fi
  fi

  max_col="$(tmux list-panes -t "$session:dev" -F '#{@column}' 2>/dev/null \
    | awk '/^[0-9]+$/ { if ($1>max) max=$1 } END { print max+0 }')"
  [[ -z "$max_col" || "$max_col" -lt 1 ]] && {
    echo "Error: no workspace columns found in $session:dev" >&2
    exit 1
  }
  new_col=$((max_col + 1))

  right_codex="$(tmux list-panes -t "$session:dev" -F '#{pane_id}:#{@role}' 2>/dev/null \
    | grep ":codex-p${max_col}$" | cut -d: -f1)"
  [[ -z "$right_codex" ]] && {
    echo "Error: rightmost codex pane (codex-p${max_col}) not found" >&2
    exit 1
  }

  new_codex="$(tmux split-window -fh -t "$right_codex" -c "$src_dir" -P -F '#{pane_id}')"
  new_claude="$(tmux split-window -v -t "$new_codex" -c "$src_dir" -l 70% -P -F '#{pane_id}')"
  sleep 0.3

  # src_alias ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  [[ -z "${src_alias:-}" ]] && src_alias="$(basename "$src_path")"

  tmux set-option -pt "$new_claude" @role "claude-p${new_col}"
  tmux set-option -pt "$new_codex" @role "codex-p${new_col}"
  tmux set-option -pt "$new_claude" @column "$new_col"
  tmux set-option -pt "$new_codex" @column "$new_col"
  tmux set-option -pt "$new_claude" @alias "$src_alias"
  tmux set-option -pt "$new_codex" @alias "$src_alias"

  claude_title="$(build_pane_label "$src_type" "$src_host" "$src_path" "CC" "$src_alias")"
  codex_title="$(build_pane_label "$src_type" "$src_host" "$src_path" "Codex" "$src_alias")"
  tmux set-option -pt "$new_claude" allow-set-title off 2>/dev/null || true
  tmux select-pane -t "$new_claude" -T "$claude_title" 2>/dev/null || true
  tmux select-pane -t "$new_codex" -T "$codex_title" 2>/dev/null || true

  if [[ "$src_type" == "remote" ]]; then
    tmux set-option -pt "$new_claude" @project "ssh://$src_host/$src_path"
    tmux set-option -pt "$new_codex" @project "ssh://$src_host/$src_path"
    tmux set-option -pt "$new_claude" @remote_host "$src_host"
    tmux set-option -pt "$new_codex" @remote_host "$src_host"
    tmux set-option -pt "$new_claude" @remote_path "$src_path"
    tmux set-option -pt "$new_codex" @remote_path "$src_path"
  else
    tmux set-option -pt "$new_claude" @project "$src_path"
    tmux set-option -pt "$new_codex" @project "$src_path"
  fi

  # å…ˆã«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ç¢ºå®šã—ã¦ã‹ã‚‰é‡ã„ãƒ—ãƒ­ã‚»ã‚¹ã‚’èµ·å‹•ã—ã€Addç›´å¾Œã®æ¨ªæºã‚Œã‚’æŠ‘ãˆã‚‹
  "$HOME/bin/rebalance-workspace-columns" "$session" 2>/dev/null || true
  sleep 0.15

  if [[ "$src_type" == "remote" ]]; then
    tmux send-keys -t "$new_claude" "ssh -t $src_host 'cd $src_path && exec \$SHELL -l'" C-m
    tmux send-keys -t "$new_codex" "ssh -t $src_host 'cd $src_path && exec \$SHELL -l'" C-m
    sleep 2

    if [[ "$NO_UPDATE" == "true" ]]; then
      tmux send-keys -t "$new_claude" "claude --continue || claude" C-m
      sleep 0.2
      tmux send-keys -t "$new_codex" "codex resume --last -s danger-full-access -a never --search" C-m
    else
      tmux send-keys -t "$new_claude" "npm update -g @anthropic-ai/claude-code; hash -r; claude --continue || claude" C-m
      sleep 0.2
      tmux send-keys -t "$new_codex" "npm update -g @openai/codex; ~/bin/sign-codex; hash -r; codex resume --last -s danger-full-access -a never --search" C-m
    fi
  else
    if has_claude_session "$src_path"; then
      claude_cmd="cd \"$src_path\" && claude --continue"
    else
      claude_cmd="cd \"$src_path\" && claude"
    fi

    if [[ "$NO_UPDATE" == "true" ]]; then
      tmux send-keys -t "$new_claude" "$claude_cmd" C-m
      sleep 0.2
      tmux send-keys -t "$new_codex" "cd \"$src_path\" && codex resume --last -s danger-full-access -a never --search" C-m
    else
      tmux send-keys -t "$new_claude" "npm update -g @anthropic-ai/claude-code; hash -r; $claude_cmd" C-m
      sleep 0.2
      tmux send-keys -t "$new_codex" "npm update -g @openai/codex; ~/bin/sign-codex; hash -r; cd \"$src_path\" && codex resume --last -s danger-full-access -a never --search" C-m
    fi
  fi

  tmux select-pane -t "$new_claude"
  tmux select-window -t "$session:dev"
  release_layout_lock
  echo "âœ… Added workspace column $new_col: $src_path" >&2
}
# === YAML ãƒ‘ãƒ¼ã‚¹ & ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰åˆ¤å®š ===
WORKSPACE_CONFIG="$HOME/.config/tproj/workspace.yaml"
WORKSPACE_MODE=false

# ã‚«ã‚¿ãƒ­ã‚°é…åˆ—ï¼ˆå…¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã€--add ã‚¨ã‚¤ãƒªã‚¢ã‚¹è§£æ±ºç”¨ï¼‰
declare -a CATALOG_PATHS
declare -a CATALOG_TYPES
declare -a CATALOG_HOSTS
declare -a CATALOG_ALIASES

# ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é…åˆ—ï¼ˆenabled=true ã®ã¿ã€èµ·å‹•ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ§‹ç¯‰ç”¨ï¼‰
declare -a PROJECT_PATHS
declare -a PROJECT_TYPES
declare -a PROJECT_HOSTS
declare -a PROJECT_ALIASES
declare -a PROJECT_CC_LAUNCH
declare -a PROJECT_CDX_LAUNCH

parse_workspace_yaml() {
  echo "ğŸ“‹ Workspace: $WORKSPACE_CONFIG" >&2

  # yq ã®å­˜åœ¨ç¢ºèª
  if ! command -v yq &>/dev/null; then
    echo "" >&2
    echo "âŒ Error: yq is not installed (required for workspace mode)" >&2
    echo "" >&2
    echo "Options:" >&2
    echo "  1. Install yq:    brew install yq" >&2
    echo "  2. Use single mode: tproj -s" >&2
    echo "  3. Remove workspace.yaml to disable workspace mode" >&2
    exit 1
  fi

  # YAML æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
  if ! yq eval '.projects[]' "$WORKSPACE_CONFIG" &>/dev/null; then
    echo "" >&2
    echo "âŒ Error: Invalid YAML syntax in $WORKSPACE_CONFIG" >&2
    echo "" >&2
    echo "Options:" >&2
    echo "  1. Fix the YAML syntax" >&2
    echo "  2. Use single mode: tproj -s" >&2
    echo "  3. Remove workspace.yaml to disable workspace mode" >&2
    exit 1
  fi

  local num_projects
  num_projects=$(yq eval '.projects | length' "$WORKSPACE_CONFIG" 2>/dev/null || echo "0")

  if [[ "$num_projects" -eq 0 ]]; then
    echo "" >&2
    echo "âŒ Error: workspace.yaml exists but contains no projects" >&2
    echo "" >&2
    echo "Example workspace.yaml:" >&2
    echo "  projects:" >&2
    echo "    - path: /path/to/project1" >&2
    echo "      type: local" >&2
    echo "    - path: ~/projects/statusline" >&2
    echo "      type: remote" >&2
    echo "      host: macmini" >&2
    exit 1
  fi

  # ç°¡æ˜“å½¢å¼ï¼ˆæ–‡å­—åˆ—ãƒªã‚¹ãƒˆï¼‰ã‹è©³ç´°å½¢å¼ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆï¼‰ã‹åˆ¤å®š
  local first_item_type
  first_item_type=$(yq eval ".projects[0] | type" "$WORKSPACE_CONFIG" 2>/dev/null)

  # NOTE: zsh ã§ã¯ path/PATH ãŒé€£å‹•ã™ã‚‹ç‰¹æ®Šå¤‰æ•°ã®ãŸã‚ proj_path ã‚’ä½¿ç”¨
  local i proj_path proj_type proj_host proj_alias proj_enabled proj_cc proj_cdx
  for ((i=0; i<num_projects; i++)); do
    if [[ "$first_item_type" == "!!str" ]]; then
      # ç°¡æ˜“å½¢å¼: æ–‡å­—åˆ—ãƒªã‚¹ãƒˆ
      proj_path=$(yq eval ".projects[$i]" "$WORKSPACE_CONFIG")
      proj_type="local"
      proj_host=""
      proj_alias="$(basename "$proj_path")"
      proj_enabled="true"
      proj_cc="true"
      proj_cdx="true"
    else
      # è©³ç´°å½¢å¼: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆ
      proj_path=$(yq eval ".projects[$i].path" "$WORKSPACE_CONFIG")
      proj_type=$(yq eval ".projects[$i].type" "$WORKSPACE_CONFIG")
      proj_host=$(yq eval ".projects[$i].host" "$WORKSPACE_CONFIG")
      proj_alias=$(yq eval ".projects[$i].alias" "$WORKSPACE_CONFIG")
      proj_enabled=$(yq eval ".projects[$i].enabled" "$WORKSPACE_CONFIG")
      proj_cc=$(yq eval ".projects[$i].cc" "$WORKSPACE_CONFIG")
      proj_cdx=$(yq eval ".projects[$i].cdx" "$WORKSPACE_CONFIG")

      # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
      [[ "$proj_type" == "null" ]] && proj_type="local"
      [[ "$proj_host" == "null" ]] && proj_host=""
      [[ "$proj_alias" == "null" ]] && proj_alias="$(basename "$proj_path")"
      [[ "$proj_enabled" == "null" ]] && proj_enabled="true"
      [[ "$proj_cc" == "null" ]] && proj_cc="true"
      [[ "$proj_cdx" == "null" ]] && proj_cdx="true"
    fi

    # ãƒ‘ã‚¹ã‚’å±•é–‹ï¼ˆ~ ã‚„ç’°å¢ƒå¤‰æ•°ï¼‰
    proj_path=$(eval echo "$proj_path")

    # åŸºæœ¬ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if [[ "$proj_type" != "local" && "$proj_type" != "remote" ]]; then
      echo "  âš ï¸  Skipping unknown type '$proj_type': $proj_path" >&2
      continue
    fi
    if [[ "$proj_type" == "remote" && -z "$proj_host" ]]; then
      echo "  âš ï¸  Skipping remote project without host: $proj_path" >&2
      continue
    fi

    # ã‚«ã‚¿ãƒ­ã‚°ã«è¿½åŠ ï¼ˆenabled å•ã‚ãšã€--add ã‚¨ã‚¤ãƒªã‚¢ã‚¹è§£æ±ºç”¨ï¼‰
    CATALOG_PATHS+=("$proj_path")
    CATALOG_TYPES+=("$proj_type")
    CATALOG_HOSTS+=("$proj_host")
    CATALOG_ALIASES+=("$proj_alias")

    # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é…åˆ—ã«ã¯ enabled=true + å­˜åœ¨ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã®ã¿
    if [[ "$proj_enabled" != "true" ]]; then
      echo "  -- [disabled] $proj_path (alias: $proj_alias)" >&2
      continue
    fi

    if [[ "$proj_type" == "local" && ! -d "$proj_path" ]]; then
      echo "  âš ï¸  Skipping non-existent: $proj_path (alias: $proj_alias)" >&2
      continue
    fi

    PROJECT_PATHS+=("$proj_path")
    PROJECT_TYPES+=("$proj_type")
    PROJECT_HOSTS+=("$proj_host")
    PROJECT_ALIASES+=("$proj_alias")
    PROJECT_CC_LAUNCH+=("$proj_cc")
    PROJECT_CDX_LAUNCH+=("$proj_cdx")

    if [[ "$proj_type" == "remote" ]]; then
      echo "  âœ… [remote@$proj_host] $proj_path (alias: $proj_alias)" >&2
    else
      echo "  âœ… [local] $proj_path (alias: $proj_alias)" >&2
    fi
  done

  echo "" >&2
}

resolve_alias_to_project() {
  local target_alias="$1"
  local i
  for ((i=0; i<${#CATALOG_ALIASES[@]}; i++)); do
    if [[ "${CATALOG_ALIASES[$i]}" == "$target_alias" ]]; then
      RESOLVED_PATH="${CATALOG_PATHS[$i]}"
      RESOLVED_TYPE="${CATALOG_TYPES[$i]}"
      RESOLVED_HOST="${CATALOG_HOSTS[$i]}"
      return 0
    fi
  done
  return 1
}

# ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰åˆ¤å®š
if [[ "$FORCE_SINGLE_MODE" == "false" && -f "$WORKSPACE_CONFIG" ]]; then
  # --add <alias> / --check æ™‚ã‚‚ãƒ‘ãƒ¼ã‚¹ãŒå¿…è¦
  if [[ "$ADD_MODE" == "false" ]] || [[ -n "$ADD_ALIAS" ]] || [[ "$CHECK_MODE" == "true" ]]; then
    parse_workspace_yaml
  fi

  # -c N: ä¸Šä½ N ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã¿ä½¿ç”¨
  if [[ -n "$MAX_COLUMNS" && "$MAX_COLUMNS" -gt 0 ]]; then
    if [[ ${#PROJECT_PATHS[@]} -gt $MAX_COLUMNS ]]; then
      PROJECT_PATHS=("${PROJECT_PATHS[@]:0:$MAX_COLUMNS}")
      PROJECT_TYPES=("${PROJECT_TYPES[@]:0:$MAX_COLUMNS}")
      PROJECT_HOSTS=("${PROJECT_HOSTS[@]:0:$MAX_COLUMNS}")
      PROJECT_ALIASES=("${PROJECT_ALIASES[@]:0:$MAX_COLUMNS}")
      echo "  columns limited to $MAX_COLUMNS (use --add to add more)" >&2
    fi
  fi

  if [[ "$ADD_MODE" == "false" && "$CHECK_MODE" == "false" ]]; then
    if [[ ${#PROJECT_PATHS[@]} -eq 0 ]]; then
      echo "" >&2
      echo "âŒ Error: No valid project directories found" >&2
      echo "" >&2
      echo "Options:" >&2
      echo "  1. Fix project paths in $WORKSPACE_CONFIG" >&2
      echo "  2. Use single mode: tproj -s" >&2
      exit 1
    fi

    # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ•°è­¦å‘Šï¼ˆ10è¶…ï¼‰
    if [[ ${#PROJECT_PATHS[@]} -gt 10 ]]; then
      echo "âš ï¸  Warning: ${#PROJECT_PATHS[@]} projects configured (panes may be narrow)" >&2
      printf "Continue anyway? [y/N] " >&2
      read -r answer
      case "$answer" in
        [yY]) ;;
        *)
          echo "Tip: Use 'tproj -s' for single-project mode" >&2
          exit 0
          ;;
      esac
    fi

    WORKSPACE_MODE=true
  fi
fi

# ãƒªãƒ¢ãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰éå¯¾å¿œãƒã‚§ãƒƒã‚¯
if [[ "$WORKSPACE_MODE" == "true" && -n "$REMOTE_HOST" ]]; then
  echo "" >&2
  echo "âŒ Error: Remote mode (-r) is not supported in workspace mode" >&2
  echo "" >&2
  echo "Options:" >&2
  echo "  1. Use single mode: tproj -s -r $REMOTE_HOST" >&2
  echo "  2. Remove -r option for local workspace mode" >&2
  exit 1
fi

if [[ "$CHECK_MODE" == "true" ]]; then
  if [[ ! -f "$WORKSPACE_CONFIG" ]]; then
    echo "No workspace config found: $WORKSPACE_CONFIG" >&2
    echo "" >&2
    echo "Create one with:" >&2
    echo "  mkdir -p ~/.config/tproj" >&2
    echo "  cp config/workspace.yaml.example ~/.config/tproj/workspace.yaml" >&2
    exit 1
  fi

  echo "Catalog (all projects):" >&2
  for ((i=0; i<${#CATALOG_ALIASES[@]}; i++)); do
    local_type="${CATALOG_TYPES[$i]}"
    local_host="${CATALOG_HOSTS[$i]}"
    local_label="[local]"
    [[ "$local_type" == "remote" ]] && local_label="[remote@$local_host]"

    # enabled åˆ¤å®š: PROJECT_PATHS ã«å«ã¾ã‚Œã¦ã„ã‚Œã° active
    is_active=false
    for ((j=0; j<${#PROJECT_PATHS[@]}; j++)); do
      if [[ "${PROJECT_PATHS[$j]}" == "${CATALOG_PATHS[$i]}" ]]; then
        is_active=true
        break
      fi
    done

    if [[ "$is_active" == "true" ]]; then
      printf "  %-20s  %-12s  %s  %s\n" "${CATALOG_ALIASES[$i]}" "$local_label" "${CATALOG_PATHS[$i]}" "" >&2
    else
      printf "  %-20s  %-12s  %s  (disabled)\n" "${CATALOG_ALIASES[$i]}" "$local_label" "${CATALOG_PATHS[$i]}" >&2
    fi
  done

  echo "" >&2
  echo "Active: ${#PROJECT_PATHS[@]} / Catalog: ${#CATALOG_ALIASES[@]}" >&2

  if [[ ${#CATALOG_ALIASES[@]} -gt ${#PROJECT_PATHS[@]} ]]; then
    echo "" >&2
    echo "Tip: Add disabled projects with: tproj --add <alias>" >&2
  fi
  exit 0
fi

if [[ "$ADD_MODE" == "true" ]]; then
  [[ -n "$REMOTE_HOST" ]] && {
    echo "Error: --add cannot be used with -r/--remote" >&2
    exit 1
  }
  [[ "$FORCE_SINGLE_MODE" == "true" ]] && {
    echo "Error: --add cannot be used with -s/--single" >&2
    exit 1
  }
  if [[ -n "$ADD_ALIAS" ]]; then
    if resolve_alias_to_project "$ADD_ALIAS"; then
      add_workspace_column "$RESOLVED_PATH" "$RESOLVED_TYPE" "$RESOLVED_HOST" "$ADD_ALIAS"
    else
      echo "Error: Unknown alias '$ADD_ALIAS'" >&2
      echo "" >&2
      echo "Available:" >&2
      for ((i=0; i<${#CATALOG_ALIASES[@]}; i++)); do
        echo "  ${CATALOG_ALIASES[$i]}  ->  ${CATALOG_PATHS[$i]}" >&2
      done
      exit 1
    fi
  else
    add_workspace_column
  fi
  exit 0
fi

# === ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ç”¨é–¢æ•° ===

# ãƒãƒ«ãƒåˆ—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ§‹ç¯‰
# å¼•æ•°: session paths[@] -- types[@] -- hosts[@] -- aliases[@]
create_workspace_layout() {
  local session="$1"
  shift

  # é…åˆ—ã‚’åˆ†é›¢ï¼ˆpaths, types, hosts, aliasesï¼‰
  local -a paths types hosts aliases
  local num_projects=0

  # æœ€åˆã®é…åˆ—çµ‚äº†ã¾ã§ paths ã«æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    paths+=("$1")
    ((num_projects++)) || true
    shift
  done
  shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—

  # types ã‚’æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    types+=("$1")
    shift
  done
  shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—

  # hosts ã‚’æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    hosts+=("$1")
    shift
  done
  shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—

  # aliases ã‚’æ ¼ç´
  while [[ $# -gt 0 ]]; do
    aliases+=("$1")
    shift
  done

  # å…¨ã¦ã® Claude ãƒšã‚¤ãƒ³ã‚’å…ˆã«æ¨ªã«ä½œæˆ
  declare -a claude_panes
  declare -a codex_panes

  # æœ€åˆã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å„ªå…ˆã€ãªã‘ã‚Œã° /tmpï¼‰
  local first_dir="${paths[0]}"
  if [[ "${types[0]}" == "remote" ]]; then
    first_dir="/tmp"  # ãƒªãƒ¢ãƒ¼ãƒˆã®å ´åˆã¯ä¸€æ™‚çš„ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
  fi
  tmux new-session -d -s "$session" -c "$first_dir" -n dev
  tmux set-option -t "$session" @tproj true
  # åˆ—å‰Šé™¤æ™‚ã«ã‚‚è‡ªå‹•ã§æ¨ªå¹…å‡ç­‰åŒ–
  tmux set-hook -t "$session" after-kill-pane "run-shell -b '$HOME/bin/rebalance-workspace-columns \"$session\"'"

  local first_codex=$(tmux list-panes -t "$session:dev" -F '#{pane_id}' | head -1)
  codex_panes[0]="$first_codex"

  # è¿½åŠ ã® Codex ãƒšã‚¤ãƒ³ã‚’æ¨ªã«ä½œæˆ
  local prev_codex="$first_codex"
  for i in $(seq 2 $num_projects); do
    local proj_path="${paths[$((i-1))]}"
    local proj_type="${types[$((i-1))]}"
    local dir="$proj_path"
    [[ "$proj_type" == "remote" ]] && dir="/tmp"

    local new_codex=$(tmux split-window -h -t "$prev_codex" -c "$dir" -P -F '#{pane_id}')
    if [[ -z "$new_codex" ]]; then
      echo "Error: failed to create column $i (window may be too narrow for $num_projects columns)" >&2
      num_projects=$((i - 1))
      break
    fi
    codex_panes[$((i-1))]="$new_codex"
    prev_codex="$new_codex"

    # å‡ç­‰åŒ–ã—ã¦æ¬¡ã®åˆ†å‰²ã«ååˆ†ãªå¹…ã‚’ç¢ºä¿
    tmux select-layout -t "$session:dev" even-horizontal 2>/dev/null || true
  done

  sleep 0.3

  # å„ Codex ã®ä¸‹ã« Claude ã‚’ä½œæˆ
  for i in $(seq 1 $num_projects); do
    local proj_path="${paths[$((i-1))]}"
    local proj_type="${types[$((i-1))]}"
    local proj_host="${hosts[$((i-1))]}"
    local dir="$proj_path"
    [[ "$proj_type" == "remote" ]] && dir="/tmp"

    local codex_pane="${codex_panes[$((i-1))]}"
    local claude_pane=$(tmux split-window -v -t "$codex_pane" -c "$dir" -l 70% -P -F '#{pane_id}')
    claude_panes[$((i-1))]="$claude_pane"

    # ã‚¿ã‚°è¨­å®š
    tmux set-option -pt "$codex_pane" @role "codex-p$i"
    tmux set-option -pt "$claude_pane" @role "claude-p$i"
    tmux set-option -pt "$codex_pane" @column "$i"
    tmux set-option -pt "$claude_pane" @column "$i"
    tmux set-option -pt "$codex_pane" @alias "${aliases[$((i-1))]}"
    tmux set-option -pt "$claude_pane" @alias "${aliases[$((i-1))]}"

    # ãƒšã‚¤ãƒ³ã‚¿ã‚¤ãƒˆãƒ«è¨­å®š
    local codex_title claude_title
    codex_title="$(build_pane_label "$proj_type" "$proj_host" "$proj_path" "Codex" "${aliases[$((i-1))]}")"
    claude_title="$(build_pane_label "$proj_type" "$proj_host" "$proj_path" "CC" "${aliases[$((i-1))]}")"
    # Claude ãŒ OSC ã‚¿ã‚¤ãƒˆãƒ«ã§ pane_title ã‚’ä¸Šæ›¸ãã™ã‚‹ãŸã‚å›ºå®šåŒ–
    tmux set-option -pt "$claude_pane" allow-set-title off 2>/dev/null || true
    tmux select-pane -t "$codex_pane" -T "$codex_title" 2>/dev/null || true
    tmux select-pane -t "$claude_pane" -T "$claude_title" 2>/dev/null || true

    # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã®ã‚¿ã‚°è¨­å®š
    if [[ "$proj_type" == "remote" ]]; then
      tmux set-option -pt "$codex_pane" @project "ssh://$proj_host/$proj_path"
      tmux set-option -pt "$claude_pane" @project "ssh://$proj_host/$proj_path"
      tmux set-option -pt "$codex_pane" @remote_host "$proj_host"
      tmux set-option -pt "$claude_pane" @remote_host "$proj_host"
      tmux set-option -pt "$codex_pane" @remote_path "$proj_path"
      tmux set-option -pt "$claude_pane" @remote_path "$proj_path"
    else
      tmux set-option -pt "$codex_pane" @project "$proj_path"
      tmux set-option -pt "$claude_pane" @project "$proj_path"
    fi

    sleep 0.2
  done

  # åˆ—å¹…ã‚’å‡ç­‰åŒ–
  local window_width=$(tmux display-message -t "$session:dev" -p '#{window_width}')
  local column_width=$((window_width / num_projects))

  for i in $(seq 0 $((num_projects - 1))); do
    local codex_pane="${codex_panes[$i]}"
    [[ -z "$codex_pane" ]] && continue
    tmux resize-pane -t "$codex_pane" -x "$column_width" 2>/dev/null || true
  done

  # git windowï¼ˆæœ€åˆã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€ãªã‘ã‚Œã° /tmpï¼‰
  local git_dir="/tmp"
  for i in $(seq 0 $((num_projects - 1))); do
    if [[ "${types[$i]}" == "local" ]]; then
      git_dir="${paths[$i]}"
      break
    fi
  done
  tmux new-window -t "$session" -n git -c "$git_dir"
}

# Codex ãƒšã‚¤ãƒ³ã‚’èµ·å‹•ï¼ˆ1åˆ—åˆ†ï¼‰
# å¼•æ•°: session no_update col_num path type host [cdx_launch]
start_codex_for_column() {
  local session="$1" no_update="$2" col="$3"
  local proj_path="$4" proj_type="$5" proj_host="$6" cdx_launch="${7:-true}"

  local codex_pane
  codex_pane=$(tmux list-panes -t "$session:dev" -F '#{pane_id}:#{@role}' \
    | grep ":codex-p${col}$" | cut -d: -f1)

  if [[ -z "$codex_pane" ]]; then
    echo "Error: Cannot find codex-p$col pane" >&2
    return 1
  fi

  if [[ "$proj_type" == "remote" ]]; then
    tmux send-keys -t "$codex_pane" \
      "ssh -t $proj_host 'cd $proj_path && exec \$SHELL -l'" C-m
    sleep 2
    if [[ "$no_update" == "true" ]]; then
      tmux send-keys -t "$codex_pane" \
        "codex resume --last -s danger-full-access -a never --search" C-m
    else
      tmux send-keys -t "$codex_pane" \
        "npm update -g @openai/codex; ~/bin/sign-codex; hash -r; codex resume --last -s danger-full-access -a never --search" C-m
    fi
  else
    # cdx: false ã®ã¨ãã¯ã‚·ã‚§ãƒ«ã§ cd ã ã‘
    if [[ "$cdx_launch" != "true" ]]; then
      tmux send-keys -t "$codex_pane" "cd \"$proj_path\"" C-m
      return
    fi
    local codex_cmd="cd \"$proj_path\" && codex resume --last -s danger-full-access -a never --search"
    if [[ "$no_update" == "true" ]]; then
      tmux send-keys -t "$codex_pane" "$codex_cmd" C-m
    else
      tmux send-keys -t "$codex_pane" \
        "npm update -g @openai/codex; ~/bin/sign-codex; hash -r; $codex_cmd" C-m
    fi
  fi
}

# Claude ãƒšã‚¤ãƒ³ã‚’èµ·å‹•ï¼ˆ1åˆ—åˆ†ï¼‰
# å¼•æ•°: session no_update col_num path type host [cc_launch]
start_claude_for_column() {
  local session="$1" no_update="$2" col="$3"
  local proj_path="$4" proj_type="$5" proj_host="$6" cc_launch="${7:-true}"

  local claude_pane
  claude_pane=$(tmux list-panes -t "$session:dev" -F '#{pane_id}:#{@role}' \
    | grep ":claude-p${col}$" | cut -d: -f1)

  if [[ -z "$claude_pane" ]]; then
    echo "Error: Cannot find claude-p$col pane" >&2
    return 1
  fi

  if [[ "$proj_type" == "remote" ]]; then
    tmux send-keys -t "$claude_pane" \
      "ssh -t $proj_host 'cd $proj_path && exec \$SHELL -l'" C-m
    sleep 2
    if [[ "$no_update" == "true" ]]; then
      tmux send-keys -t "$claude_pane" "claude --continue || claude" C-m
    else
      tmux send-keys -t "$claude_pane" \
        "npm update -g @anthropic-ai/claude-code; hash -r; claude --continue || claude" C-m
    fi
  else
    # cc: false ã®ã¨ãã¯ã‚·ã‚§ãƒ«ã§ cd ã ã‘
    if [[ "$cc_launch" != "true" ]]; then
      tmux send-keys -t "$claude_pane" "cd \"$proj_path\"" C-m
      return
    fi
    local claude_cmd
    if has_claude_session "$proj_path"; then
      claude_cmd="cd \"$proj_path\" && claude --continue"
    else
      claude_cmd="cd \"$proj_path\" && claude"
    fi
    if [[ "$no_update" == "true" ]]; then
      tmux send-keys -t "$claude_pane" "$claude_cmd" C-m
    else
      tmux send-keys -t "$claude_pane" \
        "npm update -g @anthropic-ai/claude-code; $claude_cmd" C-m
    fi
  fi
}

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ¥ãƒ„ãƒ¼ãƒ«èµ·å‹•ï¼ˆMCP ãƒ•ã‚§ãƒ¼ã‚ºåˆ¶å¾¡ä»˜ãï¼‰
# å¼•æ•°: session no_update paths[@] -- types[@] -- hosts[@] -- aliases[@] -- cc_launches[@] -- cdx_launches[@]
start_workspace_tools() {
  local session="$1"
  local no_update="$2"
  shift 2

  # é…åˆ—ã‚’åˆ†é›¢ï¼ˆpaths, types, hosts, aliases, cc_launches, cdx_launchesï¼‰
  local -a paths types hosts aliases cc_launches cdx_launches
  local num_projects=0

  # æœ€åˆã®é…åˆ—çµ‚äº†ã¾ã§ paths ã«æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    paths+=("$1")
    ((num_projects++)) || true
    shift
  done
  shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—

  # types ã‚’æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    types+=("$1")
    shift
  done
  shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—

  # hosts ã‚’æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    hosts+=("$1")
    shift
  done
  shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—

  # aliases ã‚’æ ¼ç´
  while [[ $# -gt 0 && "$1" != "--" ]]; do
    aliases+=("$1")
    shift
  done

  # cc_launches ã‚’æ ¼ç´ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
  if [[ $# -gt 0 ]]; then
    shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—
    while [[ $# -gt 0 && "$1" != "--" ]]; do
      cc_launches+=("$1")
      shift
    done
  fi

  # cdx_launches ã‚’æ ¼ç´ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
  if [[ $# -gt 0 ]]; then
    shift  # "--" ã‚’ã‚¹ã‚­ãƒƒãƒ—
    while [[ $# -gt 0 ]]; do
      cdx_launches+=("$1")
      shift
    done
  fi

  # --- MCP phased startup (chrome-ai-bridge Primary/Proxy coordination) ---

  # Phase 1: Start column 1 Codex only, wait for Primary MCP
  start_codex_for_column "$session" "$no_update" 1 \
    "${paths[0]}" "${types[0]}" "${hosts[0]}" "${cdx_launches[0]:-true}"

  if [[ $num_projects -gt 1 ]]; then
    "$HOME/bin/tproj-mcp-init" wait-primary 10 \
      || "$HOME/bin/tproj-mcp-init" log-failure "phase1"
  fi

  # Phase 2: Staggered secondary Codex connections
  # Batch 1: columns 2-3
  local batch_started=false
  for col in 2 3; do
    [[ $col -le $num_projects ]] || continue
    start_codex_for_column "$session" "$no_update" "$col" \
      "${paths[$((col-1))]}" "${types[$((col-1))]}" "${hosts[$((col-1))]}" "${cdx_launches[$((col-1))]:-true}"
    batch_started=true
  done
  if [[ "$batch_started" == "true" ]]; then
    sleep 3
    "$HOME/bin/tproj-mcp-init" check \
      || "$HOME/bin/tproj-mcp-init" log-failure "phase2-batch1"
  fi

  # Batch 2: columns 4-7
  batch_started=false
  for col in 4 5 6 7; do
    [[ $col -le $num_projects ]] || continue
    start_codex_for_column "$session" "$no_update" "$col" \
      "${paths[$((col-1))]}" "${types[$((col-1))]}" "${hosts[$((col-1))]}" "${cdx_launches[$((col-1))]:-true}"
    batch_started=true
  done
  if [[ "$batch_started" == "true" ]]; then
    sleep 3
    "$HOME/bin/tproj-mcp-init" check \
      || "$HOME/bin/tproj-mcp-init" log-failure "phase2-batch2"
  fi

  # Claude panes: all columns simultaneously (no chrome-ai-bridge conflict)
  for i in $(seq 1 $num_projects); do
    start_claude_for_column "$session" "$no_update" "$i" \
      "${paths[$((i-1))]}" "${types[$((i-1))]}" "${hosts[$((i-1))]}" "${cc_launches[$((i-1))]:-true}"
    sleep 0.2
  done

  # æœ€åˆã® Claude ãƒšã‚¤ãƒ³ã‚’é¸æŠ
  local first_claude
  first_claude=$(tmux list-panes -t "$session:dev" -F '#{pane_id}:#{@role}' \
    | grep ':claude-p1$' | cut -d: -f1)
  [[ -n "$first_claude" ]] && tmux select-pane -t "$first_claude"
}

# === å˜ä¸€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼ˆå¾“æ¥ãƒ­ã‚¸ãƒƒã‚¯ï¼‰ ===

root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
name="$(basename "$root")"

# === ã‚»ãƒƒã‚·ãƒ§ãƒ³åæ±ºå®š ===
if [[ "$WORKSPACE_MODE" == "true" ]]; then
  session="tproj-workspace"
else
  # ãƒªãƒ¢ãƒ¼ãƒˆæ™‚ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³åã«ãƒ›ã‚¹ãƒˆåã‚’ä»˜åŠ ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã¨å…±å­˜å¯èƒ½ã«ï¼‰
  if [[ -n "$REMOTE_HOST" ]]; then
    safe_host="${REMOTE_HOST//\./-}"
    session="${name}@${safe_host}"
  else
    session="$name"
  fi
  # tmuxã‚»ãƒƒã‚·ãƒ§ãƒ³åã«ä½¿ãˆãªã„æ–‡å­—ã‚’æ½°ã™ï¼ˆ@ã¯è¨±å¯ï¼‰
  session="${session//[^A-Za-z0-9_@-]/_}"
fi

# === åŒåã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚ã‚Œã°å†ä½œæˆ ===
if tmux has-session -t "$session" 2>/dev/null; then
  # Collect descendant PIDs before killing (MCP servers etc.)
  local_desc=$(collect_session_descendants "$session") || true
  tmux kill-session -t "$session" 2>/dev/null || true
  kill_surviving_descendants "$local_desc"
fi

# Clean up orphaned MCP server processes from previous sessions
cleanup_orphaned_mcp

# Workspace mode: aggressive chrome-ai-bridge cleanup (Phase 0)
if [[ "$WORKSPACE_MODE" == "true" ]]; then
  "$HOME/bin/tproj-mcp-init" cleanup
fi

# === ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½œæˆ & ãƒ„ãƒ¼ãƒ«èµ·å‹• ===
if [[ "$WORKSPACE_MODE" == "true" ]]; then
    # --- ãƒãƒ«ãƒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ¼ãƒ‰ ---
    create_workspace_layout "$session" "${PROJECT_PATHS[@]}" -- "${PROJECT_TYPES[@]}" -- "${PROJECT_HOSTS[@]}" -- "${PROJECT_ALIASES[@]}"
    # GUI ã‚¢ãƒ—ãƒªèµ·å‹•ï¼ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®Œæˆå¾Œã€ãƒ„ãƒ¼ãƒ«èµ·å‹•å‰ï¼‰
    launch_tproj_gui
    start_workspace_tools "$session" "$NO_UPDATE" "${PROJECT_PATHS[@]}" -- "${PROJECT_TYPES[@]}" -- "${PROJECT_HOSTS[@]}" -- "${PROJECT_ALIASES[@]}" -- "${PROJECT_CC_LAUNCH[@]}" -- "${PROJECT_CDX_LAUNCH[@]}"

    tmux select-window -t "$session:dev"
  else
    # --- å˜ä¸€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ¼ãƒ‰ ---
    # "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ«ãƒ¼ãƒˆ"ã‚’ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã™ã‚‹ï¼ˆgitãªã‚‰rootã€ç„¡ã‘ã‚Œã°cwdï¼‰
    root="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"

    # 1) dev window ã‚’ä½œæˆ
    tmux new-session -d -s "$session" -c "$root" -n dev
    tmux set-option -t "$session" @tproj true

    # 2) VSCodeã£ã½ã„3ãƒšã‚¤ãƒ³ï¼ˆå·¦ãƒ¡ã‚¤ãƒ³ / å³ä¸Šwatch / å³ä¸‹logsï¼‰
    tmux split-window -h -t "$session:dev" -c "$root"
    tmux split-window -v -t "$session:dev.2" -c "$root" -l 70%

    # splitç›´å¾Œã®PTYãƒãƒƒãƒ•ã‚¡å®‰å®šå¾…ã¡ï¼ˆã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹æ¼ã‚Œé˜²æ­¢ï¼‰
    sleep 0.3

    # 3) ãƒšã‚¤ãƒ³ã« @role ã‚¿ã‚°ã‚’è¨­å®šï¼ˆAgent Teams å‹•çš„ãƒšã‚¤ãƒ³ç®¡ç†ç”¨ï¼‰
    tmux set-option -pt "$session:dev.1" @role "claude"
    tmux set-option -pt "$session:dev.2" @role "codex"
    tmux set-option -pt "$session:dev.3" @role "yazi"
    tmux set-option -pt "$session:dev.1" @alias "$name"
    tmux set-option -pt "$session:dev.2" @alias "$name"
    tmux set-option -pt "$session:dev.3" @alias "$name"

    # 3.1) ãƒšã‚¤ãƒ³ã‚¿ã‚¤ãƒˆãƒ«è¨­å®šï¼ˆClaude/Codexã®ã¿ï¼‰
    title_host="local"
    [[ -n "$REMOTE_HOST" ]] && title_host="$REMOTE_HOST"
    claude_title=""
    codex_title=""
    claude_title="$(build_pane_label "${REMOTE_HOST:+remote}" "$title_host" "$root" "CC" "$name")"
    codex_title="$(build_pane_label "${REMOTE_HOST:+remote}" "$title_host" "$root" "Codex" "$name")"
    # å˜ä¸€ãƒ¢ãƒ¼ãƒ‰ã® Claude ã§ã‚‚ã‚¿ã‚¤ãƒˆãƒ«ä¸Šæ›¸ãã‚’æŠ‘æ­¢
    tmux set-option -pt "$session:dev.1" allow-set-title off 2>/dev/null || true
    tmux select-pane -t "$session:dev.1" -T "$claude_title" 2>/dev/null || true
    tmux select-pane -t "$session:dev.2" -T "$codex_title" 2>/dev/null || true

    # 4) git windowï¼ˆå·®åˆ†ã‚„ãƒ­ã‚°ç”¨ï¼‰
    tmux new-window -t "$session" -n git -c "$root"

    # GUI ã‚¢ãƒ—ãƒªèµ·å‹•ï¼ˆå…¨ãƒšã‚¤ãƒ³ä½œæˆå¾Œã€ãƒ„ãƒ¼ãƒ«èµ·å‹•å‰ï¼‰
    launch_tproj_gui

    # 5) ã‚³ãƒãƒ³ãƒ‰ã‚’è‡ªå‹•èµ·å‹•ï¼ˆãƒªãƒ¢ãƒ¼ãƒˆ/ãƒ­ãƒ¼ã‚«ãƒ«ã§åˆ†å²ï¼‰
    if [[ -n "$REMOTE_HOST" ]]; then
      # --- ãƒªãƒ¢ãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰: å…ˆã«SSHã‚·ã‚§ãƒ«ã‚’èµ·å‹•ã—ã€ãƒ„ãƒ¼ãƒ«ã¯å¾Œã‹ã‚‰é€ä¿¡ ---
      # SSHã§ãƒªãƒ¢ãƒ¼ãƒˆã®ãƒ­ã‚°ã‚¤ãƒ³ã‚·ã‚§ãƒ«ã«å…¥ã‚‹ï¼ˆãƒ„ãƒ¼ãƒ«çµ‚äº†å¾Œã‚‚ã‚·ã‚§ãƒ«ãŒæ®‹ã‚‹ï¼‰
      for pane in 1 2 3; do
        tmux send-keys -t "$session:dev.$pane" \
          "ssh -t $REMOTE_HOST 'cd $root && exec \$SHELL -l'" C-m
      done
      tmux send-keys -t "$session:git" \
        "ssh -t $REMOTE_HOST 'cd $root && exec \$SHELL -l'" C-m

      # SSHæ¥ç¶šå¾…ã¡
      sleep 2

      # ãƒªãƒ¢ãƒ¼ãƒˆã‚·ã‚§ãƒ«å†…ã§ãƒ„ãƒ¼ãƒ«ã‚’èµ·å‹•
      if [[ "$NO_UPDATE" == "true" ]]; then
        tmux send-keys -t "$session:dev.1" "claude --continue || claude" C-m
        sleep 0.1
        tmux send-keys -t "$session:dev.2" "codex resume --last -s danger-full-access -a never --search" C-m
      else
        tmux send-keys -t "$session:dev.1" "npm update -g @anthropic-ai/claude-code; hash -r; claude --continue || claude" C-m
        sleep 0.1
        tmux send-keys -t "$session:dev.2" "npm update -g @openai/codex; ~/bin/sign-codex; hash -r; codex resume --last -s danger-full-access -a never --search" C-m
      fi

      sleep 0.3
      tmux send-keys -t "$session:dev.3" "yazi" C-m
    else
      # --- ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¢ãƒ¼ãƒ‰ ---
      # ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ‰ç„¡ã«å¿œã˜ãŸèµ·å‹•ã‚³ãƒãƒ³ãƒ‰ã‚’æ§‹ç¯‰
      if has_claude_session "$root"; then
        claude_cmd="claude --continue"
      else
        claude_cmd="claude"
      fi

      if [[ "$NO_UPDATE" == "true" ]]; then
        tmux send-keys -t "$session:dev.1" "$claude_cmd" C-m
        sleep 0.1
        tmux send-keys -t "$session:dev.2" "codex resume --last -s danger-full-access -a never --search" C-m
      else
        tmux send-keys -t "$session:dev.1" "npm update -g @anthropic-ai/claude-code; hash -r; $claude_cmd" C-m
        sleep 0.1
        tmux send-keys -t "$session:dev.2" "npm update -g @openai/codex; ~/bin/sign-codex; hash -r; codex resume --last -s danger-full-access -a never --search" C-m
      fi

      sleep 0.3
      tmux send-keys -t "$session:dev.3" "yazi" C-m

      tmux send-keys -t "$session:git" "echo 'ğŸŒ¿ git (status/diff/log)'" C-m
    fi

    tmux select-window -t "$session:dev"
    tmux select-pane -t "$session:dev.1"
fi

exec tmux attach -t "$session"

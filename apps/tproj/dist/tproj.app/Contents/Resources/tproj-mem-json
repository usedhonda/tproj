#!/usr/bin/env python3
import argparse
import json
import os
import re
import shutil
import subprocess
import sys
from collections import defaultdict, deque
from datetime import datetime, timezone

VERSION = "1.0.0"

CC_RE = re.compile(r"claude|anthropic", re.IGNORECASE)
MCP_RE = re.compile(r"mcp|context7|playwright|chrome-ai-bridge|modelcontextprotocol", re.IGNORECASE)
CODEX_RE = re.compile(r"codex|openai", re.IGNORECASE)


def run(cmd):
    try:
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=False)
        return proc.returncode, proc.stdout, proc.stderr
    except Exception as exc:
        return 1, "", str(exc)


def load_cc_mem(errors):
    script_dir = os.path.dirname(os.path.realpath(__file__))
    bundled = os.path.join(script_dir, "cc-mem")
    home_bin = os.path.join(os.path.expanduser("~"), "bin", "cc-mem")
    candidates = [home_bin, bundled]
    which = shutil.which("cc-mem")
    if which and which not in candidates:
        candidates.append(which)

    for cmd in candidates:
        if not os.path.exists(cmd):
            continue
        code, out, err = run([cmd, "--json"])
        if code != 0:
            errors.append(f"cc-mem failed ({cmd}): {err.strip() or out.strip()}")
            continue
        try:
            return json.loads(out)
        except Exception as exc:
            errors.append(f"cc-mem invalid json ({cmd}): {exc}")
            continue

    errors.append("cc-mem not found")
    return {}


def load_tmux_panes(errors):
    code, out, err = run([
        "tmux", "list-panes", "-a",
        "-F", "#{session_name}\t#{window_name}\t#{pane_id}\t#{pane_index}\t#{pane_pid}\t#{@role}\t#{@column}\t#{@project}"
    ])
    if code != 0:
        errors.append(f"tmux list-panes failed: {err.strip() or out.strip()}")
        return []

    panes = []
    for line in out.splitlines():
        if not line.strip():
            continue
        parts = line.split("\t")
        if len(parts) < 8:
            continue
        pane_pid = parse_int(parts[4])
        if pane_pid is None:
            continue
        panes.append({
            "session": parts[0],
            "window": parts[1],
            "pane_id": parts[2],
            "pane_index": parse_int(parts[3]) or -1,
            "pane_pid": pane_pid,
            "role": parts[5] or "",
            "column": parse_int(parts[6]),
            "project_raw": parts[7] or "",
        })
    return panes


def load_ps_tree(errors):
    code, out, err = run(["ps", "-axo", "pid=,ppid=,rss=,pcpu=,command="])
    if code != 0:
        errors.append(f"ps failed: {err.strip() or out.strip()}")
        return {}, defaultdict(list)

    procs = {}
    children = defaultdict(list)

    for line in out.splitlines():
        line = line.strip()
        if not line:
            continue
        parts = line.split(None, 4)
        if len(parts) < 4:
            continue
        pid = parse_int(parts[0])
        ppid = parse_int(parts[1])
        rss = parse_int(parts[2])
        cpu = parse_float(parts[3])
        cmd = parts[4] if len(parts) > 4 else ""
        if pid is None or ppid is None or rss is None:
            continue

        procs[pid] = {
            "ppid": ppid,
            "rss_kb": rss,
            "cpu": cpu,
            "cmd": cmd,
        }
        children[ppid].append(pid)

    return procs, children


def parse_int(value):
    try:
        return int(str(value).strip())
    except Exception:
        return None


def parse_float(value):
    try:
        return float(str(value).strip())
    except Exception:
        return 0.0


def normalize_project_name(raw):
    raw = (raw or "").strip()
    if not raw:
        return ""
    if raw.startswith("ssh://"):
        stripped = raw[len("ssh://"):]
        if "/" in stripped:
            raw = stripped[stripped.find("/"):]
    raw = raw.rstrip("/")
    if not raw:
        return ""
    return os.path.basename(raw)


def detect_agent_type(role, pane_cmd):
    role = (role or "").lower()
    if role.startswith("claude"):
        return "cc"
    if role.startswith("codex"):
        return "codex"

    cmd = (pane_cmd or "").lower()
    if CC_RE.search(cmd):
        return "cc"
    if CODEX_RE.search(cmd):
        return "codex"
    return "other"


def descendant_pids(root_pid, children_map):
    seen = set()
    queue = deque([root_pid])
    while queue:
        pid = queue.popleft()
        if pid in seen:
            continue
        seen.add(pid)
        for child in children_map.get(pid, []):
            if child not in seen:
                queue.append(child)
    return seen


def pane_usage(root_pid, procs, children_map):
    if root_pid not in procs:
        return 0, 0.0, {"C": 0, "M": 0, "X": 0, "O": 0}

    pids = descendant_pids(root_pid, children_map)
    total_kb = 0
    total_cpu = 0.0
    bucket_kb = {"C": 0, "M": 0, "X": 0, "O": 0}

    for pid in pids:
        proc = procs.get(pid)
        if not proc:
            continue
        cmd = proc["cmd"]
        rss_kb = proc["rss_kb"]
        total_kb += rss_kb
        total_cpu += proc["cpu"]

        if CC_RE.search(cmd):
            bucket = "C"
        elif MCP_RE.search(cmd):
            bucket = "M"
        elif CODEX_RE.search(cmd):
            bucket = "X"
        else:
            bucket = "O"
        bucket_kb[bucket] += rss_kb

    bucket_mb = {key: int(round(val / 1024.0)) for key, val in bucket_kb.items()}
    return int(round(total_kb / 1024.0)), round(total_cpu, 1), bucket_mb


def build_snapshot():
    errors = []
    cc_mem = load_cc_mem(errors)
    panes = load_tmux_panes(errors)
    procs, children = load_ps_tree(errors)

    cc_proc_project_by_pid = {}
    for proc in cc_mem.get("cc_processes", []) or []:
        pid = proc.get("pid")
        project = proc.get("project")
        if isinstance(pid, int) and isinstance(project, str):
            cc_proc_project_by_pid[pid] = project

    pane_rows = []
    col_map = {}

    for pane in panes:
        pane_proc = procs.get(pane["pane_pid"], {})
        pane_cmd = pane_proc.get("cmd", "")
        agent_type = detect_agent_type(pane["role"], pane_cmd)
        if agent_type not in ("cc", "codex"):
            continue

        rss_mb, cpu, bucket_mb = pane_usage(pane["pane_pid"], procs, children)
        if rss_mb > 0:
            state = "active" if cpu >= 2.0 else "idle"
        else:
            state = "unknown"

        project_name = normalize_project_name(pane["project_raw"])
        if not project_name and agent_type == "cc":
            pid_set = descendant_pids(pane["pane_pid"], children)
            for pid in pid_set:
                mapped = cc_proc_project_by_pid.get(pid)
                if mapped and mapped != "--":
                    project_name = normalize_project_name(mapped)
                    if project_name:
                        break

        pane_row = {
            "session": pane["session"],
            "window": pane["window"],
            "pane_id": pane["pane_id"],
            "pane_index": pane["pane_index"],
            "role": pane["role"],
            "column": pane["column"],
            "project": project_name,
            "rss_mb": rss_mb,
            "cpu": cpu,
            "bucket_c_mb": bucket_mb["C"],
            "bucket_m_mb": bucket_mb["M"],
            "bucket_x_mb": bucket_mb["X"],
            "bucket_o_mb": bucket_mb["O"],
            "state": state,
            "agent_type": agent_type,
        }
        pane_rows.append(pane_row)

        if pane["column"] is not None and pane["column"] > 0:
            col = col_map.setdefault(pane["column"], {
                "column": pane["column"],
                "project": "",
                "cc_mb": 0,
                "codex_mb": 0,
                "total_mb": 0,
                "cc_active": 0,
                "codex_active": 0,
            })
            if not col["project"] and project_name:
                col["project"] = project_name
            if agent_type == "cc":
                col["cc_mb"] += rss_mb
                if state == "active":
                    col["cc_active"] += 1
            elif agent_type == "codex":
                col["codex_mb"] += rss_mb
                if state == "active":
                    col["codex_active"] += 1
            col["total_mb"] = col["cc_mb"] + col["codex_mb"]

    pane_rows.sort(key=lambda r: ((r.get("column") or 9999), r.get("agent_type", ""), r.get("pane_index") or -1, r.get("pane_id", "")))
    columns = [col_map[key] for key in sorted(col_map.keys())]

    snapshot = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "system": cc_mem.get("system", {"total_mb": 0, "used_mb": 0, "free_mb": 0}),
        "categories": cc_mem.get("categories", {}),
        "cc_processes": cc_mem.get("cc_processes", []),
        "guard": cc_mem.get("guard", "unknown"),
        "panes": pane_rows,
        "columns": columns,
        "collector": {
            "version": f"tproj-mem-json/{VERSION}",
            "source": "cc-mem+tmux+ps",
            "errors": errors,
        },
    }
    return snapshot


def main():
    parser = argparse.ArgumentParser(description="tproj merged memory monitor json")
    parser.add_argument("--version", action="store_true", help="show version")
    parser.add_argument("--pretty", action="store_true", help="pretty json")
    parser.add_argument("--json", action="store_true", help="json output (default)")
    args = parser.parse_args()

    if args.version:
        print(f"tproj-mem-json v{VERSION}")
        return 0

    data = build_snapshot()
    if args.pretty:
        print(json.dumps(data, ensure_ascii=False, indent=2))
    else:
        print(json.dumps(data, ensure_ascii=False, separators=(",", ":")))
    return 0


if __name__ == "__main__":
    sys.exit(main())
